# NI-488.2/GPIB32 API
対話式制御における従来のボードレベルNI-488.2コールの構文

|No.|関数名|説明|
|-|-|-|
|1|[ibask](#ibaskボードレベルデバイスレベル)|ソフトウェア構成パラメータについての情報を返します。|
|2|[ibcac](#ibcacボードレベル)|アクティブコントローラになります。|
|3|[ibcmd](#ibcmdボードレベル)|GPIBコマンドを送信します。|
|4|[ibcmda](#ibcmdaボードレベル)|GPIBコマンドを非同期に送信します。|
|5|[ibconfig](#ibconfigボードレベルデバイスレベル)|ソフトウェア構成パラメータを変更します。|
|6|ibdma|DMAを有効または無効にします。|
|7|ibeos|EOS（End-Of-String）終了モードまたはEOS文字を構成します。|
|8|ibeot|書き込みI/O処理の終わりでのGPIB EOIラインの自動アサートを有効または無効にします。|
|9|[ibfind](#ibfindボードレベルデバイスレベル)|インタフェースまたはユーザ構成の計測器デスクリプタを開いて、初期化します。|
|10|[ibgts](#ibgtsボードレベル)|アクティブコントローラからスタンバイに移行します。|
|11|ibist|パラレルポール用のボードの個々のステータスビットを設定またはクリアします。|
|12|[iblck](#iblckボードレベルデバイスレベル)|実行中のプロセスの排他的インタフェースロックを取得または解放します。|
|13|[iblines](#iblinesボードレベル)|8つのGPIBコントロールラインのステータスを返します。|
|14|[ibln](#iblnボードレベル)|バス上にデバイスが存在するかどうかを調べます。|
|15|[ibloc](#iblocボードレベルデバイスレベル)|ボードをローカルモードにします。|
|16|[ibnotify](#ibnotifyボードレベルデバイスレベル)|ユーザのコールバックを呼び出して、1つまたは複数のGPIBイベントをユーザに通知します。|
|17|[ibonl](#ibonlボードレベルデバイスレベル)|デバイスをオンラインまたはオフラインにします。|
|18|ibpad|プライマリアドレスを変更します。|
|19|[ibppc](#ibppcボードレベルデバイスレベル)|パラレルポールを構成します。|
|20|[ibrd](#ibrdボードレベルデバイスレベル)|計測器からユーザバッファにデータを読み取ります。|
|21|[ibrda](#ibrdaボードレベルデバイスレベル)|計測器からユーザバッファに非同期でデータを読み取ります。|
|22|[ibrdf](#ibrdfボードレベルデバイスレベル)|計測器からファイルにデータを読み取ります。|
|23|[ibrpp](#ibrppボードレベルデバイスレベル)|パラレルポーリングを行います。|
|24|ibrsc|システム制御を要求または解放します。|
|25|ibrsv|サービスを要求してシリアルポールのステータスバイトを変更します。|
|26|ibsad|セカンダリアドレスを変更するか無効にします。|
|27|[ibsic](#ibsicボードレベル)|IFC（Interface Clear: インタフェースのクリア）をアサートします。|
|28|ibsre|REN（Remote Enable）ラインを設定またはクリアします。|
|29|[ibstop](#ibstopボードレベルデバイスレベル)|非同期の入出力処理を中断します。|
|30|ibtmo|I/Oタイムアウト時間を変更するか無効にします。|
|31|[ibwait](#ibwaitボードレベルデバイスレベル)|GPIBイベントを待機します。|
|32|[ibwrt](#ibwrtボードレベルデバイスレベル)|ユーザバッファから計測器にデータを書き込みます。|
|33|[ibwrta](#ibwrtaボードレベルデバイスレベル)|ユーザバッファから計測器に非同期でデータを書き込みます。|
|34|[ibwrtf](#ibwrtfボードレベルデバイスレベル)|ファイルから計測器にデータを書き込みます。|

## ibask（ボードレベル/デバイスレベル）
### 目的
ソフトウェア構成パラメータに関する情報を返します。

### 形式
``` C
unsigned int ibask (int ud, int option, int *value)
```
### 対話式制御
```
ibask option
```

### 入力
- ud：ボードまたはデバイスのユニットデスクリプタ
- option：値が要求されている構成項目を選択

### 出力
- value：選択されている構成項目の現在値
- 関数からの戻り値：Ibstaの値。

### 説明
ibaskは、指定のボードやデバイスに関する各種構成パラメータの現在値を返します。選択された構成項目の現在値は、整数valueに返されます。ibaskの有効な構成パラメータオプションの一覧を参照してください。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EARG|optionの構成パラメータが無効です。ibaskボード構成パラメータオプションおよびibaskデバイス構成パラメータオプションを参照してください。|
|ECAP|optionがドライバに適していないか、インタフェースが正しく構成されていません。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibcac（ボードレベル）
### 目的
アクティブなコントローラにします。

### 形式
``` C
unsigned int ibcac (int ud, int v)
```
### 対話式制御
```
ibcac v
```

### 入力
- ud：ボードのユニットデスクリプタ
- v：制御権の取得を非同期または同期で行うかを決定します。

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
指定のGPIBインタフェースは、ibcacを使用してATNをアサートすることで、アクティブコントローラになろうとします。vが0の場合、GPIBインタフェースは非同期で制御権を取得します。 vが0以外の値の場合、GPIBインタフェースは同期で制御権を取得します。ibcacを呼び出しする前に、GPIBインタフェースを必ずCICにしてください。ボードをCICにするには、ibsic関数を使用します。
同期で制御権を取得するために、GPIBインタフェースは転送されたデータを損なわずにATN信号をアサートしようとします。これが不可能な場合、ボードは非同期で制御権を取得します。
非同期で制御権を取得するために、GPIBインタフェースは現在進行中のデータ転送を無視して直ちにATN信号をアサートします。
ほとんどのアプリケーションでは、ibcacを使う必要がありません。ibcmdなどのATNをアサートする必要がある呼び出しは、自動的にアサートを実行します。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EARG|udは有効ですが、インタフェースを参照していません。|
|ECIC|インタフェースがCIC（Controller-In-Charge: コントローラインチャージ）でありません。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibclr（デバイスレベル）
### 目的
指定されたデバイスをクリアします。

### 形式
``` C
unsigned int ibclr (int ud)
```
### 対話式制御
```
ibclr
```

### 入力
- ud：デバイスのユニットデスクリプタ

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
ibclrは、GPIB SDC（Selected Device Clear:選択デバイスのクリア）メッセージをudで記述したデバイスに送信します。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EBUS|デバイスがGPIBに接続されていません。|
|ECIC|アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibcmd（ボードレベル）
### 目的
GPIBコマンドを送信します。

### 形式
``` C
unsigned int ibcmd (int ud, const void *cmdbuf, size_t count)
``` 
### 対話式制御
```
ibcmd cmdbuf
```

### 入力
- ud：ボードのユニットデスクリプタ
- cmdbuf: 送信するコマンドバイトのバッファ
- count：送信するコマンドバイト数

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
ibcmdは、countバイトをcmdbufからGPIB上にコマンドバイト（インタフェースメッセージ）として送信します。転送されたコマンドバイト数はグローバル関数Ibcntに返されます。インタフェースメッセージの定義は、IEEE 488コマンドメッセージの一覧を参照してください。
コマンドバイトは、GPIBの状態を構成するために使用します。GPIBデバイスに命令を送信するためのものではありません。デバイス特定の指示を送信するには、ibwrtを使用します。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EABO|すべてのコマンドバイトが送信される前に、タイムアウト時間が経過しました。|
|ECIC|インタフェースがCIC（Controller-In-Charge: コントローラインチャージ）でありません。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|ENOL|GPIBにリスナがありません。|
|EOIP|非同期I/Oの処理中です。|

## ibcmda（ボードレベル）
### 目的
GPIBコマンドを非同期に送信します。

### 形式
``` C
unsigned int ibcmda (int ud, const void *cmdbuf, size_t count)
```
### 対話式制御
```
ibcmda cmdbuf
```

### 入力
- ud：ボードのユニットデスクリプタ
- cmdbuf: 送信するコマンドバイトのバッファ
- count：送信するコマンドバイト数

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
ibcmdaは、countバイトをcmdbufからGPIB上にコマンドバイト（インタフェースメッセージ）として送信します。転送されたコマンドバイト数はグローバル関数Ibcntに返されます。インタフェースメッセージの定義は、IEEE 488コマンドメッセージの一覧を参照してください。
コマンドバイトは、GPIBの状態を構成するために使用します。GPIBデバイスに命令を送信するためのものではありません。デバイス特定の指示を送信するには、ibwrtを使用します。
非同期のI/O呼び出し（ibcmda、ibrda、ibwrta ）は、I/O処理中にアプリケーションがGPIB以外の処理を実行できるように設計されています。非同期のI/Oが開始されると、後続のNI-488.2呼び出しは厳しく制限されます。実行中のI/O処理を干渉するような呼び出しはすべて拒否されます。 この場合、ドライバがEOIPを返します。
I/Oが完了したら、アプリケーションはNI-488.2ドライバと再同期化する必要があります。再同期化を行うには、以下のいずれかの呼び出しを使用してください。

ibwait 返されたIbstaにCMPLが含まれている場合、ドライバとアプリケーションは再同期化されています。
ibnotify ibnotify Callbackに渡されたIbstaの値にCMPLが含まれている場合、ドライバとアプリケーションは再同期化されています。
ibstop I/Oが取り消され、ドライバとアプリケーションが再同期化されます。
ibonl I/Oが取り消されインタフェースはリセットされて、ドライバとアプリケーションが再同期化されます。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|ECIC|インタフェースがCIC（Controller-In-Charge: コントローラインチャージ）でありません。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|ENOL|GPIBにリスナがありません。|
|EOIP|非同期I/Oの処理中です。|

## ibconfig（ボードレベル/デバイスレベル）
### 目的
ソフトウェアの構成入力を変更します。

### 形式
``` C
unsigned int ibconfig (int ud, int option, int value)
``` 
### 対話式制御
```
ibconfig option value
```

### 入力
- ud：ボードまたはデバイスのユニットデスクリプタ
- option: ソフトウェア構成項目を選択するパラメータ
- value: 選択された構成項目の変更値

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
ibconfigは、選択したボードまたはデバイスの構成項目を指定の値に変更します。 optionは、定義済みのオプションならばどれでも指定できます（ibconfigボード構成パラメータオプションまたはibconfigデバイス構成パラメータオプションを参照してください）。 valueは、構成するパラメータに対して有効な値でなければなりません。構成項目の以前の設定内容は、Iberrに返されます。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EARG|optionまたはvalueのいずれかが有効ではありません。有効なオプションは、ibconfigボード構成パラメータオプションibconfigボード構成パラメータオプションの一覧に記載されています。|
|ECAP|ドライバが変更要求を実行できません。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|
|ESAC|ボードにシステムコントローラ機能がありません。|

## ibdev（デバイスレベル）
### 目的
デバイスデスクリプタを開いて初期化します。

### 形式
``` C
int ibdev (int BdIndx, int pad, int sad, int tmo, int eot, int eos)
```
### 対話式制御
```
ibdev BdIndx pad sad tmo eot eos
```

### 入力
- BdIndx: デバイス用アクセスボードの指標
- pad: デバイスのプライマリGPIBアドレス
- sad: デバイスのセカンダリGPIBアドレス
- tmo: I/Oタイムアウト値
- eot: デバイスのEOIモード
- eos: EOS文字とモード

### 出力
- 関数からの戻り値：デバイスデスクリプタまたは-1

### 説明
ibdevは、デバイスデスクリプタを獲得し、後続のデバイスレベルのNI-488.2呼び出しで使用します。デバイスデスクリプタを開いて初期化し、入力パラメータに従ってこれを構成します。

各入力パラメータの詳細と意味については、ibconfigのIbcPAD、IbcSAD、IbcTMO、IbcEOT、IbcEOSオプションを参照してください。

ibdevが有効なデスクリプタを獲得できない場合は、-1が返されます。 また、IbstaにERRビットが設定され、IberrにEDVRが設定されます。

メモ メモ ユニットデスクリプタは各プロセス毎に割り当てられるため、プロセス間でユニットデスクリプタを共有することはできません。あるプロセスから別のプロセスにユニットデスクリプタを渡すと、2番目のプロセスでそのデスクリプタを使用するすべてのNI-488.2呼び出しからEDVRが返されます。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EARG|pad、sad、tmo、eot、またはeosのいずれかが無効です。これらのパラメータの設定については、ibconfigのIbcPAD、IbcSAD、IbcTMO、IbcEOT、IbcEOSオプションを参照してください。|
|EBUS|デバイスがGPIBに接続されていません。|
|ECIC|アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibfind（ボードレベル/デバイスレベル）
### 目的
ボードまたはユーザが構成したデバイスのデスクリプタを開いて初期化します

### 形式
``` C
int ibfind (const char *udname)
```
### 対話式制御
```
ibfind udname
```

### 入力
- udname: ユーザが構成したデバイスまたはボード名

### 出力
- 関数からの戻り値：ボードまたはデバイスデスクリプタ、あるいは-1

### 説明
ibfindを使って、ボードまたはユーザ構成デバイスのデスクリプタを取得します。 このボードまたはデバイスデスクリプタは、後続のNI-488.2呼び出しで使用できます。

ibfindは、ibonl 1と同様に機能し、ボードまたはデバイスデスクリプタを初期化します。ibfindが返すユニットデスクリプタは、ibonl 0を使用してボードまたはデバイスをオフラインにするまで有効です。

ibfindが有効なデスクリプタを獲得できない場合は、-1が返されます。 また、IbstaにERRビットが設定され、IberrにEDVRが設定されます。

メモ メモ ユニットデスクリプタは各プロセス毎に割り当てられるため、プロセス間でユニットデスクリプタを共有することはできません。あるプロセスから別のプロセスにユニットデスクリプタを渡すと、2番目のプロセスでそのデスクリプタを使用するすべてのNI-488.2呼び出しからEDVRが返されます。

ibfindを使用したデバイスデスクリプタの取得は、既存のアプリケーションとの互換性を持たせる場合にのみ役立ちます。新規アプリケーションでは、ibfindの代わりにibdevを使用します。 ibdev はより柔軟性に富み、使いやすく、アプリケーションはデバイス名の使用を必要としなくなります。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EBUS|デバイスレベル: デバイスがGPIBに接続されていません。|
|ECIC|デバイスレベル: アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|ELCK|インタフェースは、他の処理によりロックされています。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|

## ibgts（ボードレベル）
### 目的
アクティブコントローラからスタンバイコントローラに移行します。

### 形式
``` C
unsigned int ibgts (int ud, int v)
```
### 対話式制御
```
ibgts v
```

### 入力
- ud：ボードデスクリプタ
- v：アクセプタハンドシェイクを実行するかどうかを決定します。

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
ibgtsにより、udのGPIBインタフェースがスタンドバイコントローラに移行され、ATN GPIBラインはアサート解除されます。vが0以外の値の場合、ENDが検出されるまで、あるいはATNが後続のibcac呼び出しによって再アサートされるまで、アクセプタハンドシェイクまたはシャドウハンドシェイクが実行されます。このオプションでは、GPIBインタフェースは実際にデータを読み取ることなくアクセプタとしてデータハンドシェイクを実行できます。ENDが検出されると、インタフェースはNRFD（Not Ready For Data）ハンドシェイクホールドオフ状態になります。 この結果、後続の GPIB 転送が保留されます。vが0の場合、アクセプタハンドシェイクもホールドオフも実行されません。

シャドウハンドシェイクでibgtsを実行する前に、ibconfigでIbcEOSオプションを呼び出して適切なEOSモードを確立してください。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EADR|vは0以外の値で、ATNが低いか、インタフェースがトーカまたはリスナです。|
|ECIC|インタフェースがCIC（Controller-In-Charge: コントローラインチャージ）でありません。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## iblck（ボードレベル/デバイスレベル）
### 目的
実行中のプロセスの排他的デバイスまたはインタフェースロックを取得または解放します。

### 形式
``` C
unsigned int iblck (int ud, int v, unsigned int LockWaitTime, void * Reserved)
```
### 対話式制御
```
iblck v LockWaitTime
```

### 入力
- ud：ボードまたはデバイスデスクリプタ
- v：インタフェースに対するロックの取得・解放を示します
- LockWaitTime:ELCKエラーを返す前の排他的ロックの有効期限（ミリ秒）
- Reserved: 今後の使用のために予約（現バージョンではNULLのみ有効）

### 出力
- 関数からの戻り値：Ibstaの値

### 説明（ボードレベル）
vが1の場合、ドライバは現在のプロセスに対してインタフェースへの排他的ロックを取得します。LockWaitTimeで指定されたタイムアウトの期間内にロックが取得されない場合、呼び出しは失敗しELCKエラーを返します（IbstaにはERR、IberrにはELCKを設定）。

vが0の場合、現在のプロセスが以前に取得したロックを解放します。インタフェースロックはそのロックを取得したプロセスのみが解放できます。vがゼロでプロセスにロックがない場合、呼び出しは失敗し、ELCKを返します。iblckを呼び出してインタフェースに対するロックを解放する際、LockWaitTimeは無視されます。

あるプロセスがロックの取得に成功した場合、そのプロセスによる、そのインタフェースに対するすべてのGPIB呼び出しは、正常に動作します。

プロセスがロックの取得に成功した場合、そのインタフェースの別のプロセスによるGPIB呼び出し（iblckとボードレベルのibfindを除く）はすべて、直ちにELCKで失敗します。他のプロセスによるiblck呼び出しは、ロックの取得を試みますが、タイムアウト時間が経過後のみ、呼び出しはELCKで失敗します。ボードレベルでのibfind呼び出しはELCKエラーを返しますが、有効なユニットデスクリプタを返します。

インタフェースのロックは、排他性がありプロセス間での共有はできません。あるプロセスがロックの取得に成功した場合、他のプロセスはそのインタフェースへのロックを取得することはできません。

プロセスは、1つのインタフェースに対し、複数の（重複した）ロックを取得することができます。ドライバはインタフェースごとの有効なロック数のリファレンスカウントを保持し、リファレンスカウントが0になるまではインタフェースのロックを解除しません。iblck呼び出しが成功した場合、つまり、ERRがIbstaに設定されない場合には、v値とは無関係に、Ibcntにはudに対して影響を持つ残りのロックの数が含まれます。

インタフェースへのロックは、プロセスとGPIBインタフェースに関連付けられています。取得されたロックは、ロックが解放されるまで有効です。iblckを呼び出ししてロックを複数回取得した場合、そのロック数と同じ回数のロック解放呼び出しが必要です。ibonl (0または1)を呼び出すと、udで指定されたインタフェースのプロセスでのすべてのインタフェースロックが解除されます。

LockWaitTimeが0の場合、待機時間が0msであることを示します。他のプロセスがインタフェースをロックしている場合、iblckは直ちにELCKエラーを返します。エラーを返さない場合、そのプロセスはロックを取得して戻ります。

### 説明（デバイスレベル）

vが1の場合、ドライバは入力デバイスデスクリプタに対してデバイスへの排他的ロックを取得します。LockWaitTimeで指定されたタイムアウトの期間内にロックが取得されない場合、呼び出しは失敗しELCKエラーを返します（IbstaにはERR、IberrにはELCKを設定）。

vが0の場合、udが以前に取得したロックを解放します。デバイスロックはそのロックを取得したデスクリプタのみが解放できます。vがゼロでデスクリプタにロックがない場合、呼び出しは失敗し、ELCKを返します。iblckを呼び出してデバイスに対するロックを解放する際、LockWaitTimeは無視されます。

デバイスロックはデスクリプタ特有です。デバイスでロックを取得するのに特定のデスクリプタが使用される場合、同じPAD/SAD構成を持つ他のデスクリプタは、そのデバイスに関連するロックを取得することができません。

2つの法則により、GPIBロックの取得要求が成功するかどうかが決まります。

アクセスボードBを持つデバイスDのロックがデスクリプタにある場合、どのプロセスもボードBでロックを取得できませんが、アクセスボードBを持つD以外のデバイスでは、プロセスがロックを取得することが可能です。
ボードBのロックがプロセスにある場合、どのプロセスも、ボードBに関連するボードまたはデバイスロックを取得できません。
デバイスロックを取得するのにデスクリプタが使用される際、そのデスクリプタを使用するすべてのGPIB呼び出しは通常、次の例外を除いて正常に動作します。ibconfigを、ibcPADまたはibcSADと一緒に呼び出すことはできません。これらの呼び出しにより、ロックされているデバイスのプライマリまたはセカンダリアドレスが変更される可能性があるため、これらの呼び出しは許可されていません。デバイスがロックされている場合、これらの呼び出しによる影響はなく、ELCKで失敗します。これらの呼び出しを使用する前に、iblckでデバイスロックを解放する必要があります。

デバイスロックがデスクリプタにある時、ロックされているPAD/SADリソースを必要とする他のデスクリプタによるデバイスレベルのGPIB呼び出し（iblckとibdevを除く）はすべて許可されておらず、Ibstaに設定されたERRビット、およびIberrに設定されたELCKビットで失敗します。そのデバイスの他のデスクリプタによるiblck呼び出しは、ロックの取得を試み、呼び出しは、タイムアウト時間が経過した後のみにELCKで失敗します。ibdevはELCKで失敗しますが、有効なユニットデスクリプタを返します。

デバイスで複数の（重複した）ロックを取得するのに、デスクリプタを使用することができます。ドライバはデバイスごとの有効なロック数のリファレンスカウントを保持し、リファレンスカウントがゼロになるまではデバイスのロックを解除しません。iblck呼び出しが成功した場合（つまり、ERRがIbstaに設定されない場合）、v値とは無関係に、Ibcntにはudに対して影響を持つ残りのロックの数が含まれます。

デバイスロックは、デバイスデスクリプタに関連しています。取得されたロックは、ロックが解放されるまで有効です。iblckを呼び出ししてロックを複数回取得した場合、そのロック数と同じ回数のロック解放呼び出しが必要です。ibonl (0または1)を呼び出すと、udで指定されたデバイスのすべてのデバイスロックが解除されます。

LockWaitTimeが0の場合、待機時間が0msであることを示します。他のプロセスがボードまたはデバイスをロックしている場合、iblckは直ちにELCKエラーを返します。エラーを返さない場合、そのプロセスはロックを取得して戻ります。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EARG|vは0または1ではないか、ReservedはNULLではありません。|
|ECAP|udのロックリファレンスカウントが最大に達したため、要求されたロックを取得できません。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|別プロセスがそのインタフェースをロックがしているため、要求したロックをタイムアウト期間内で取得できません。または、プロセスにはudに対するロックがないため、ロックを解放できません。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## iblines（ボードレベル）
### 目的
GPIBの8本の制御ラインのステータスを返します。

### 形式
``` C
unsigned int iblines (int ud, short *clines)
```
### 対話式制御
```
iblines
```

### 入力
- ud：ボードデスクリプタ

### 出力
- clines: GPIB制御ラインの状態情報を返します
- 関数からの戻り値：Ibstaの値

### 説明
iblinesは、GPIB制御ラインの状態をclinesに返します。clinesの下位バイト（ビット0から7）には、GPIBの各制御ラインのステータスを検知するGPIBインタフェースボードの機能を示すマスクが含まれます。上位バイト（ビット8～15）には、GPIB制御ラインのステータス情報が設定されます。各バイトのパターンを次に示します。

|7|6|5|4|3|2|1|0|
|-|-|-|-|-|-|-|-|
|EOI|ATN|SRQ|REN|IFC|NRFD|NDAC|DAV|

GPIB制御ラインがアサートされているかどうかを判断するには、まず下位バイトの該当ビットを調べ、ラインを監視できるかどうかを確認します。ラインが監視できる（該当ビット位置が1になっている）場合は、次に上位バイトの対応するビットを調べます。ビットが設定（1）されている場合、該当する制御ラインはアサートされています。このビットがクリア（0）であれば、制御ラインはアサートされていません。

サンプル
``` C
short lines;
iblines (ud, &lines);
if (lines & ValidREN) {
   /* check to see if REN is asserted */
   if (lines & BusREN) {
      printf ("REN is asserted");
   }
}
```

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibln（ボードレベル）
### 目的
バス上にデバイスが存在するかどうかを調べます。

### 形式
``` C
unsigned int ibln (int ud, int pad, int sad, short *listen)
```
### 対話式制御
```
ibln pad sad
```

### 入力
- ud：ボードデスクリプタ
- pad: デバイスのプライマリGPIBアドレス
- sad: デバイスのセカンダリGPIBアドレス

### 出力
- listen: デバイスが存在するかどうかを示します
- 関数からの戻り値：Ibstaの値

### 説明
iblnは、padおよびsadパラメータで指定されたGPIBアドレスにリスナに設定されたデバイスが存在するかどうかを確認します。ボードに関連付けられたバスがリスナのテスト対象になります。リスナを検出すると、listenに0以外の値が返されます。リスナが見つからなかった場合は、0が返されます。

padパラメータには、有効なプライマリアドレス（0～30の値）を任意に使用できます。sadパラメータには、有効なプライマリアドレス（96～126の値）、あるいは定数NO_SADかALL_SADのいずれかを使用できます。定数NO_SADは、セカンダリアドレスをテストしないように指定します（プライマリアドレスのみがテストされます）。定数ALL_SADは、すべてのセカンダリアドレスをテストするように指定します。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EARG|padまたはsadいずれかの引数が無効です。|
|EBUS|デバイスがGPIBに接続されていません。|
|ECIC|アクセスボードがCICでありません。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibloc（ボードレベル/デバイスレベル）
### 目的
ローカルに移行します。

### 形式
``` C
unsigned int ibloc (int ud)
```
### 対話式制御
```
ibloc
```

### 入力
- ud：ボードまたはデバイスデスクリプタ

### 出力
- 関数からの戻り値：Ibstaの値

### 説明（ボードレベル）
iblocは、ボードがロックアウト状態でない場合、ボードをローカルモードにします。ステータスワードIbstaにLOKが表示される場合、ボードはロックアウト状態です。ボードがロックアウト状態の場合は、呼び出しても何も起こりません。
ibloc関数はコンピュータを計測器として使用している場合に、フロントパネルのRTL（ローカルモードに返る）スイッチのシミュレーションに使用されます。

### 説明（デバイスレベル）
REN（Remote Enable: リモート有効）ラインがibconfig関数のIbcSREオプションでアサート解除されていないかぎり、デバイスレベルの呼び出しは指定されたデバイスを自動的にリモートプログラムモードにします。デバイス上で次のデバイス関数を実行するまで、そのデバイスを一時的にリモートプログラムモードからローカルモードに移行するには、iblocを使用します。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EBUS|デバイスレベル: デバイスがGPIBに接続されていません。|
|ECIC|デバイスレベル: アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibnotify（ボードレベル/デバイスレベル）
### 目的
ユーザのコールバックを呼び出して、1つまたは複数のGPIBイベントをユーザに通知します。

### ibnotifyの形式
``` C
unsigned int ibnotify (int ud, int mask, GpibNotifyCallback_t Callback, void * RefData)
```
### 対話式制御
```
サポートなし
```

### ibnotifyの入力
- ud：ボードまたはデバイスデスクリプタ
- mask：通知するGPIBイベントのビットマスク
- Callback：コールバック関数へのポインタ（以下のプロトタイプを参照）
- RefData：ユーザ定義のコールバック用参照データ

### ibnotifyの出力
- 関数からの戻り値：Ibstaの値

### ibnotifyの説明
maskが0以外の値の場合、ibnotifyはmaskが指定したイベントを監視し、発生したイベントがあれば指定のCallbackを呼び出します。ボードレベルのibnotify呼び出しでは、ERRとRQS以外のすべてのマスクビットが有効です。デバイスレベルのibnotify呼び出しでは、有効なマスクビットはCMPL、TIMO、END、およびRQSのみです。TIMOが通知マスクに設定されている場合、タイムアウト時間を超過した時、その他の指定イベントが既に発生していなければ、ibnotifyはCallback関数を呼び出します。TIMOが通知マスクに設定されていない場合、指定イベントが1つ以上発生するまでCallback関数は呼び出されません。

### メモ 
1つ以上のmaskビットの状態がTRUEの場合に、通知が実行されます。 CMPLがTRUEの時に通知をするように要求すると、現在CMPLがTRUEである場合、直ちにCallbackが呼び出されます。

デバイスレベルの使用では、自動シリアルポーリングが無効に設定されている場合、RQSの通知が正しく機能しない場合があります。デフォルトで、自動シリアルポーリングは有効になっています。

所定のudに有効なibnotify呼び出しは、一度につき１つだけです。現行のibnotifyがudに対して有効な場合、これは後続のibnotify呼び出しで置き替えられます。udに対して有効なibnotify呼び出しは、udに対する後続のibnotify呼び出しのmaskを0に指定する事により、取り消されます。

ibnotify呼び出しが有効で、待機している1つ以上のGPIBイベントの状態がTRUEになると、Callbackが呼び出されます。

ボードやデバイス（つまり、ud）をオフラインにする前に、有効なibnotify呼び出しはすべて、マスクが0であるudに対して後続のibnotify呼び出しでキャンセルする必要があります。

## ibnotifyのコールバックプロトタイプ
``` C
int __stdcall Callback (int LocalUd, unsigned int LocalIbsta, unsigned int LocalIberr, unsigned int LocalIbcnt, void *RefData)
```

### コールバックパラメータ
- LocalUd ボードまたはデバイスデスクリプタ
- LocalIbsta Ibstaの値
- LocalIberr Iberrの値
- LocalIbcnt Ibcntの値
- RefData ユーザ定義のコールバック用参照データ

### コールバックの戻り値
次に通知するGPIBイベントのビットマスク

Callback関数は、プロセスの別のスレッドで実行されます。したがって、任意のプロセスのグローバルデータにはアクセスできますが、スレッドのローカルデータにはアクセスできません。Callbackがグローバルデータにアクセスする必要がある場合は、Callbackは別のスレッドコンテキストで実行されているため、同期プリミティブ（例えば、セマフォ）を使ってそのアクセスを保護する必要があります。あるいは、CallbackがWindowsのPostMessage()関数を使って単にアプリケーションにメッセージを送るだけの場合は、このデータ保護はまったく実行せずに済みます。Callback関数は、ibnotify以外のNI-488.2 APIすべてを呼び出すことができます。Callbackが呼び出されると、NI-488.2グローバル関数（Ibsta、Iberr、Ibcnt）の値が未定義になります。Callbackが呼び出された理由を判断するには、NI-488.2グローバル関数ではなく、Callbackに渡されたステータス関数/変数を調べます。1つ以上の要求されたmaskビットの設定が原因なのではなく、エラー状況によりCallbackが呼び出された可能性があることに注意してください。

Callbackの戻り値は、非同期イベント通知メカニズムを自動的に再登録するのに使用されるマスク値として解釈されます。戻り値が0の場合、再登録は行われません。戻り値が0以外の値の場合、非同期イベント通知メカニズムは戻されたマスク値を使って再登録されます。エラーのためCallbackの再登録に失敗した場合には、Callbackは、ERRが設定されたLocalIbstaやEARMが設定されたLocalIberrとともに呼び出されます。

ibwait、ibstop、およびibonlと同様、非同期I/O処理が完了した後、ibnotify Callbackの呼び出しによってハンドラを再同期化できます。この場合、I/O処理が完了した後でCallbackに渡されるグローバル関数/変数にI/O処理のステータスが含まれています。

NI-488.2アプリケーションでの非同期イベント通知の概要については、非同期イベント通知のセクションを参照してください。使用法についての詳細は、ibnotifyの使用のセクションを参照してください。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EARG|maskに設定されたビットが無効です。|
|ECAP|ibnotifyがibnotify Callback関数内から呼び出されたか、ハンドラが1つ以上指定されたmaskビットについて通知を実行できません。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。Ibcntには、システム依存エラーコードが含まれます。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EARM|Callbackの戻り値がCallbackの再登録に失敗しました。|
|ERST|インタフェースのリセットが原因でイベント通知がキャンセルされました。|

## ibonl（ボードレベル/デバイスレベル）
### 目的
デバイスまたはインタフェースをオンラインまたはオフラインにします。

### 形式
``` C
unsigned int ibonl (int ud, int v)
```
### 対話式制御
```
ibonl v
```

### 入力
- ud：ボードまたはデバイスデスクリプタ
- v：ボードまたはデバイスをオンラインまたはオフラインにすることを示します

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
ibonlは、ボードやデバイスをリセットし、ソフトウェア構成パラメータをすべて構成前の状態に戻します。また、vが0の場合は、デバイス/インタフェースボードはオフラインになります。vが0以外の値の場合は、デバイス/インタフェースボードは処理できる状態、つまりオンライン状態のままになります。

デバイスまたはインタフェースがオフラインになると、ボードまたはデバイスのデスクリプタ（ud）はもはや有効でなくなります。ibdevまたはibfindを実行して、ボードまたはデバイスに再びアクセスする必要があります。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|

## ibpct（デバイスレベル）
### 目的
コントローラ機能を持つ別のGPIBデバイスにコントロールを渡します。

### 形式
``` C
unsigned int ibpct (int ud)
```
### 対話式制御
```
ibpct
```

### 入力
- ud：デバイスデスクリプタ

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
ibpctは、udで指定するデバイスにCIC（Controller-In-Charge: コントローラインチャージ）ステータスを渡します。アクセスボードは自動的にATNラインをアサート解除し、CIDS（Controller Idle State: コントローラアイドル状態）に移行します。この関数は、デバイスがコントローラ機能を持っていることを前提としています。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EARG|udは有効ですが、デバイスを参照していません。|
|EBUS|デバイスがGPIBに接続されていません。|
|ECIC|アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibppc（ボードレベル/デバイスレベル）
### 目的
パラレルポールを構成します。

### 形式
``` C
unsigned int ibppc (int ud, int v)
```
### 対話式制御
```
ibppc v
```

### 入力
- ud：ボードまたはデバイスデスクリプタ
- v：パラレルポールを有効または無効にする値

### 出力
- 関数からの戻り値：Ibstaの値

### 説明（デバイスレベル）
udがデバイスデスクリプタの場合、ibppcはパラレルポールに応答するようにデバイスを有効化または無効化します。この際、デバイスはアドレス指定されて、PPE（Parallel Poll Enable: パラレルポール有効）またはPPD（Parallel Poll Disable: パラレルポール無効）のいずれかのパラレルポールメッセージが送信されます。有効なパラレルポールメッセージは、96～126（16進数で60～7E）またはPPDを設定する0です。

### 説明（ボードレベル）
udがボードデスクリプタの場合、パラレルポール構成値のvを使用して、ibppcはローカルのパラレルポール構成を実行します。有効なパラレルポールメッセージは、96～126（16進数で60～7E）またはPPDに送信するゼロです。呼び出し中にエラーが発生しなかった場合は、以前のローカルパラレルポールの設定値がIberrに返されます。

パラレルポーリングについての詳細は、パラレルポーリングのセクションを参照してください。パラレルポールメッセージについては、IEEE 488 コマンドメッセージを参照してください。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EARG|vには、有効なPPEまたはPPDメッセージが含まれていません。|
|EBUS|デバイスレベル: デバイスがGPIBに接続されていません。|
|ECAP|ボードレベル: ボードはローカルパラレルポールを行うように構成されていません。（ibconfigのIbcPP2オプションを参照してください）。|
|ECIC|デバイスレベル: アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibrd（ボードレベル/デバイスレベル）
### 目的
デバイスからユーザバッファにデータを読み取ります。

### 形式
``` C
unsigned int ibrd (int ud, void *rdbuf, size_t count)
```
### 対話式制御
```
ibrd count
```

### 入力
- ud：ボードまたはデバイスデスクリプタ
- count：GPIBから読み取るバイト数

### 出力
- rdbuf：データが読み取られるバッファのアドレス
- 関数からの戻り値：Ibstaの値

### 説明（デバイスレベル）
udがデバイスデスクリプタの場合、ibrdはGPIBのアドレスを指定し、countバイトまでのデータ読み取り、rdbufで指定されたバッファにデータを入れます。countバイトのデータを受信するかENDを受信すると、操作は正常終了します。タイムアウト時間内に転送が完了できないと、処理はエラーで終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

### 説明（ボードレベル）
udがボードデスクリプタの場合、ibrdはcountバイトまでのデータをGPIBデバイスから読み取りrdbufによって指定されたバッファにそのデータを配置します。ボードレベルのibrdは、GPIBがすでに正しくアドレス指定されているものと仮定します。countバイトのデータを受信するかENDを受信すると、操作は正常終了します。転送をタイムアウト時間内に完了できなかったり、あるいはボードがCICでない場合にCICがGPIB上でDCL（Device Clear: デバイスクリア）を送信すると、操作はエラーで終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EABO|タイムアウト時間内にcountバイトまたはENDを受信しなかったか、あるいは読み取り処理の開始後にDCL（Device Clear: デバイスクリア）を受信しました。|
|EADR|ボードレベル: GPIBが正しくアドレス指定されませんでした。ibcmdを使ってGPIBをアドレス指定してください。デバイスレベル: デバイスのGPIBアドレスとアクセスボードのGPIBアドレス間に競合が存在します。代わりにibconfig（IbcPADとIbcSAD）を使用してください。|
|EARG|バッファまたはcountが無効です。|
|EBUS|デバイスレベル: デバイスがGPIBに接続されていません。|
|ECIC|デバイスレベル: アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibrda（ボードレベル/デバイスレベル）
### 目的
デバイスからユーザバッファにデータを非同期的に読み取ります。

### 形式
``` C
unsigned int ibrda (int ud, void *rdbuf, size_t count)
```
### 対話式制御
```
ibrda count
```

### 入力
- ud：ボードまたはデバイスのユニットデスクリプタ
- count：GPIBから読み取るバイト数

### 出力
- rdbuf：データが読み取られるバッファのアドレス
- 関数からの戻り値：Ibstaの値

### 説明（デバイスレベル）
udがデバイスデスクリプタの場合、ibrdaはGPIBのアドレスを指定し、countバイトまでのデータをGPIBデバイスから非同期に読み取り、rdbufで指定されたバッファにデータを入れます。countバイトのデータを受信するかENDを受信すると、操作は正常終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

### 説明（ボードレベル）
udがボードデスクリプタの場合、ibrdaはcountバイトまでのデータをGPIBデバイスから読み取りrdbufによって指定されたバッファにそのデータを配置します。ボードレベルのibrdaは、GPIBがすでに正しくアドレス指定されているものと仮定します。countバイトのデータを受信するかENDを受信すると、操作は正常終了します。ボードがCICでなく、CICがGPIB上でDCL（Device Clear: デバイスクリア）を送信すると、操作はエラーで終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

### 説明（ボードレベル/デバイスレベル）
非同期のI/O呼び出し（ibcmda、ibrda、ibwrta）は、I/O処理中にアプリケーションがGPIB以外の処理を実行できるように設計されています。非同期のI/Oが開始されると、後続のNI-488.2呼び出しは厳しく制限されます。実行中のI/O処理を干渉するような呼び出しはすべて拒否されます。 この場合、ドライバがEOIPを返します。

I/Oが完了したら、アプリケーションはNI-488.2ドライバと再同期化する必要があります。再同期化を行うには、以下のいずれかの呼び出しを使用してください。

ibwait 返されたIbstaにCMPLが含まれている場合、ドライバとアプリケーションは再同期化されています。
ibnotify ibnotify Callbackに渡されたIbstaの値にCMPLが含まれている場合、ドライバとアプリケーションは再同期化されています。
ibstop I/Oが取り消され、ドライバとアプリケーションが再同期化されます。
ibonl I/Oが取り消されインタフェースはリセットされて、ドライバとアプリケーションが再同期化されます。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EABO|ボードレベル: CICからDCL（Device Clear: デバイスクリア）のメッセージを受信しました。|
|EADR|ボードレベル: GPIBが正しくアドレス指定されませんでした。ibcmdを使ってGPIBをアドレス指定してください。デバイスレベル: デバイスのGPIBアドレスとアクセスボードのGPIBアドレス間に競合が存在します。代わりにibconfig（IbcPADとIbcSAD）を使用してください。|
|EARG|バッファまたはcountが無効です。|
|EBUS|デバイスレベル: デバイスがGPIBに接続されていません。|
|ECIC|デバイスレベル: アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibrdf（ボードレベル/デバイスレベル）
### 目的
デバイスからファイルにデータを読み取ります。

### 形式
``` C
unsigned int ibrdf (int ud, const char *flname)
```
### 対話式制御
```
ibrdf flname
```

### 入力
- ud：ボードまたはデバイスデスクリプタ
- flname：データを読み取り先のファイル名

### 出力
- 関数からの戻り値：Ibstaの値

### 説明（デバイスレベル）
udがデバイスデスクリプタの場合、ibrdfはGPIBをアドレス指定し、GPIBデバイスからデータを読み取り、flnameによって指定されたファイルにそのデータを配置します。ENDを受信すると操作は正常終了します。タイムアウト時間内に転送が完了できないと、処理はエラーで終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

### 説明（ボードレベル）
udがボードデスクリプタの場合、ibrdfはGPIBデバイスからデータを読み取り、flnameよって指定されたファイルにそのデータを配置します。ボードレベルのibrdfは、GPIBがすでに正しくアドレス指定されているものと仮定します。ENDを受信すると操作は正常終了します。転送をタイムアウト時間内に完了できなかったり、あるいはボードがCICでない場合にCICがGPIB上でDCL（Device Clear: デバイスクリア）を送信すると、操作はエラーで終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EABO|タイムアウト時間内にENDを受信しなかったか、あるいはudがボードデスクリプタで、読み取り処理を開始後にDCL（Device Clear: デバイスクリア）を受信しました。|
|EADR|ボードレベル: GPIBが正しくアドレス指定されませんでした。ibcmdを使ってGPIBをアドレス指定してください。デバイスレベル: デバイスのGPIBアドレスとアクセスボードのGPIBアドレス間に競合が存在します。代わりにibconfig（IbcPADとIbcSAD）を使用してください。|
|EARG|flnameが無効です。|
|EBUS|デバイスレベル: デバイスがGPIBに接続されていません。|
|ECIC|デバイスレベル: アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EFSO|ibrdfがflnameにアクセスできませんでした。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibrpp（ボードレベル/デバイスレベル）
### 目的
パラレルポールを実行します。

### 形式
``` C
unsigned int ibrpp (int ud, char *ppr)
```
### 対話式制御
```
ibrpp
```

### 入力
- ud：ボードまたはデバイスデスクリプタ

### 出力
- ppr：パラレルポールの応答バイト
- 関数からの戻り値：Ibstaの値

### 説明
ibrppは、GPIB上のすべてのデバイスに対してパラレルポールを実行します。このポールの結果はpprに返されます。

パラレルポーリングについての詳細はパラレルポーリングの概要を参照してください。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EBUS|デバイスレベル: デバイスがGPIBに接続されていません。|
|ECIC|デバイスレベル: アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibrsp（デバイスレベル）
### 目的
シリアルポールを実行します。

### 形式
``` C
unsigned int ibrsp (int ud, char *spr)
```
### 対話式制御
```
ibrsp
```

### 入力
- ud：デバイスデスクリプタ

### 出力
- spr：シリアルポール応答バイト
- 関数からの戻り値：Ibstaの値

### 説明
ibrspは、デバイスudに対してシリアルポールを実行するのに使用されます。シリアルポール応答バイトはsprに返されます。応答バイトにビット6（16進値の40）が設定されている場合、デバイスはサービスを要求しています。自動シリアルポーリング機能が有効になっている場合、デバイスはすでにポールされている可能性があります。この場合、ibrspは以前に獲得したステータスバイトを返します。

シリアルポーリングについての詳細は、シリアルポーリングの概要を参照してください。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EABO|シリアルポールのタイムアウト時間内にシリアルポールの応答を読み取れませんでした。|
|EBUS|デバイスがGPIBに接続されていません。|
|ECIC|アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibsic（ボードレベル）
### 目的
インタフェースクリアをアサートします。

### 形式
``` C
unsigned int ibsic (int ud)
```
### 対話式制御
```
ibsic
```

### 入力
- ud：ボードデスクリプタ

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
ibsicは、GPIBインタフェースがシステムコントローラの場合、GPIBのIFC（Interface Clear: インタフェースクリア）ラインを少なくとも100μs間アサートし、その後解除します。IFCをアサートすると、バスのすべてのデバイスのアドレス指定を解除し、インタフェースボードがCICになります。

IFC信号がリセットするのは、デバイスのGPIBインタフェース機能の部分だけです。 デバイスの内部機能はリセットしません。デバイスの内部機能のリセット方法については、ご使用のデバイスに付属のマニュアルを参照してください。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|
|ESAC|ボードにシステムコントローラ機能がありません。|

## ibstop（ボードレベル/デバイスレベル）
### 目的
非同期のI/O処理を中断します。

### 形式
``` C
unsigned int ibstop (int ud)
```
### 対話式制御
```
ibstop
```

### 入力
- ud：ボードまたはデバイスデスクリプタ

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
ibstop関数は、実行中の非同期の読み取り処理、書き込み処理、コマンド処理をすべて中止し、その処理を行っていたアプリケーションとドライバを再同期化します。非同期のI/Oを処理中の場合は、ステータスワードIbstaにエラービットが設定されてEABOが返されます。 これは、I/Oが正常に停止したことを示します。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EABO|非同期のI/Oが正常に停止されました。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|

## ibtrg（デバイスレベル）
### 目的
選択されているデバイスをトリガします。

### 形式
``` C
unsigned int ibtrg (int ud)
```
### 対話式制御
```
ibtrg
```

### 入力
- ud：デバイスデスクリプタ

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
ibtrgは、GET（Group Execute Trigger: グループトリガ実行）メッセージをudで指定されているデバイスに送信します。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EBUS|デバイスがGPIBに接続されていません。|
|ECIC|アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|

## ibwait（ボードレベル/デバイスレベル）
### 目的
定義されたGPIBイベントが発行されるまで待機します。

### 形式
``` C
unsigned int ibwait (int ud, int mask)
```
### 対話式制御
```
ibwait mask
```

### 入力
- ud：ボードまたはデバイスデスクリプタ
- mask：待機するGPIBイベントのビットマスク

### 出力
- 関数からの戻り値：Ibstaの値

### 説明
ibwaitは、マスクによって指定されたイベントを監視し、1つまたは複数のイベントが発生するまで待機します。マスクがゼロの場合、ibwaitは更新されたIbstaステータスワードとともに直ちに戻ります。待機マスクにTIMOが設定されている場合、ibwaitはタイムアウト時間が経過した時点で指定イベントが発生しない場合に呼び出しを終了します。TIMOが待機マスクに設定されていない場合、この関数は指定されている1つまたは複数のイベントが発生するまで待ちます。現在使用できるibwaitマスクビットは、Ibstaのビットと同じです。udがデバイスデスクリプタの場合、有効な待機マスクビットは、TIMO、END、RQS、およびCMPLのみです。udがボードデスクリプタの場合、RQSを除くすべての待機マスクビットが有効です。タイムアウトの有効期限は、ibconfig関数（IbcTMOオプション）を使用して構成されます。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EARG|maskに設定されたビットが無効です。|
|EBUS|デバイスレベル: デバイスがGPIBに接続されていません。|
|ECIC|デバイスレベル: アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|ESRQ|デバイスレベル: RQSが待機マスクに設定されていると、ESRQはSRQが固定状態であることを示します。シリアルポーリングについての詳細は、シリアルポーリングの概要を参照してください。|
|EWIP|指定されたユニットデスクリプタに対し、ibwait呼び出しが既に開始されています。|
|ERST|インタフェースのリセットが原因でイベント通知がキャンセルされました。|

## ibwrt（ボードレベル/デバイスレベル）
### 目的
ユーザバッファからデバイスにデータを書き込みます。

### 形式
``` C
unsigned int ibwrt (int ud, const void *wrtbuf, size_t count)
```
### 対話式制御
```
ibwrt wrtbuf
```

### 入力
- ud：ボードまたはデバイスデスクリプタ
- wrtbuf：書き込むバイトが格納されているバッファのアドレス
- count：書き込むバイト数

### 出力
- 関数からの戻り値：Ibstaの値

### 説明（デバイスレベル）
udがデバイスデスクリプタの場合、ibwrtはGPIBのアドレスを指定し、countバイトをwrtbufで指定されたメモリ位置からGPIBデバイスに書き込みます。countバイトが送信されると操作は正常終了します。タイムアウト時間内にcountバイトが送信できないと、処理はエラーで終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

### 説明（ボードレベル）
udがボードデスクリプタの場合、ibwrtはwrtbufによって指定されたバッファからcountバイトをGPIBデバイスに書き込みます。 ボードレベルのibwrtは、GPIBがすでに正しくアドレス指定されているものと仮定します。countバイトが送信されると操作は正常終了します。countバイトをタイムアウト時間内に送信できなかったり、ボードがCICでない場合、CICがGPIB上でDCL（Device Clear: デバイスクリア）を送信すると、エラーが発生して操作が終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EABO|タイムアウト時間内にcountバイトを送信しなかったか、または書き込み操作を開始後にDCL（Device Clear: デバイスクリア）を受信しました。|
|EADR|ボードレベル: GPIBが正しくアドレス指定されませんでした。ibcmdを使ってGPIBをアドレス指定してください。デバイスレベル: デバイスのGPIBアドレスとアクセスボードのGPIBアドレス間に競合が存在します。代わりにIbcPAD（IbcSADとibconfig）を使用してください。|
|EARG|バッファまたはcountが無効です。|
|EBUS|デバイスレベル: デバイスがGPIBに接続されていません。|
|ECIC|デバイスレベル: アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|ENOL|バス上にリスナが検出されませんでした。|
|EOIP|非同期I/Oの処理中です。|

## ibwrta（ボードレベル/デバイスレベル）
### 目的
ユーザバッファからデバイスにデータを非同期に書き込みます。

### 形式
``` C
unsigned int ibwrta (int ud, const void *wrtbuf, size_t count)
- ibwrta wrtbuf
```

### 入力
- ud：ボードまたはデバイスデスクリプタ
- wrtbuf：書き込むバイトが格納されているバッファのアドレス
- count：書き込むバイト数

### 出力
- 関数からの戻り値：Ibstaの値

### 説明（デバイスレベル）
udがデバイスデスクリプタの場合、ibwrtaはGPIBを適切にアドレス指定して、countバイトをwrtbufで指定されたバッファからGPIBデバイスに書き込みます。countバイトが送信されると操作は正常終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

### 説明（ボードレベル）
udがボードデスクリプタの場合、ibwrtaはwrtbufからcountバイトをGPIBデバイスに非同期で書き込む操作を開始します。ボードレベルのibwrtfは、GPIBがすでに正しくアドレス指定されているものと仮定します。countバイトが送信されると操作は正常終了します。ボードがCICでなく、CICがGPIB上でDCL（Device Clear: デバイスクリア）を送信すると、操作はエラーで終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

ボードレベル/デバイスレベル
非同期のI/O呼び出し（ibcmda、ibrda、ibwrta）は、I/O処理中にアプリケーションがGPIB以外の処理を実行できるように設計されています。非同期のI/Oが開始されると、後続のNI-488.2呼び出しは厳しく制限されます。実行中のI/O処理を干渉するような呼び出しはすべて拒否されます。 この場合、ドライバがEOIPを返します。

I/Oが完了したら、アプリケーションはNI-488.2ドライバと再同期化する必要があります。再同期化を行うには、以下のいずれかの呼び出しを使用してください。

ibwait 返されたIbstaにCMPLが含まれている場合、ドライバとアプリケーションは再同期化されています。
ibnotify ibnotify Callbackに渡されたIbstaの値にCMPLが含まれている場合、ドライバとアプリケーションは再同期化されています。
ibstop I/Oが取り消され、ドライバとアプリケーションが再同期化されます。
ibonl I/Oが取り消されインタフェースはリセットされて、ドライバとアプリケーションが再同期化されます。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EABO|ボードレベル: CICからDCL（Device Clear: デバイスクリア）のメッセージを受信しました。|
|EADR|ボードレベル: GPIBが正しくアドレス指定されませんでした。ibcmdを使ってGPIBをアドレス指定してください。デバイスレベル: デバイスのGPIBアドレスとアクセスボードのGPIBアドレス間に競合が存在します。代わりにIbcPAD（IbcSADとibconfig）を使用してください。|
|EARG|バッファまたはcountが無効です。|
|EBUS|デバイスレベル: デバイスがGPIBに接続されていません。|
|ECIC|デバイスレベル: アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|ENOL|バス上にリスナが検出されませんでした。|
|EOIP|非同期I/Oの処理中です。|

## ibwrtf（ボードレベル/デバイスレベル）
### 目的
データをファイルからデバイスに書き込みます。

### 形式
``` C
unsigned int ibwrtf (int ud, const char *flname)
```
### 対話式制御
```
ibwrtf flname
```

### 入力
- ud：ボードまたはデバイスデスクリプタ
- flname：書き込むデータが格納されているファイル名

### 出力
- 関数からの戻り値：Ibstaの値

### 説明（デバイスレベル）
udがデバイスデスクリプタの場合、ibwrtfはGPIBをアドレス指定して、すべてのバイトをファイルflnameからGPIBデバイスに書き込みます。すべてのバイトが送信されると操作は正常終了します。タイムアウト内にすべてのバイトを送信できないと、エラーが発生して操作が終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

### 説明（ボードレベル）
udがボードデスクリプタの場合、ibwrtfはすべてのバイトをファイルflnameからGPIBデバイスに書き込みます。ボードレベルのibwrtfは、GPIBがすでに正しくアドレス指定されているものと仮定します。すべてのバイトが送信されると操作は正常終了します。タイムアウト内にすべてのバイトを送信できなかったり、ボードがCICでない場合CICがGPIB上でDCL（Device Clear）を送信すると、操作はエラーで終了します。転送された実際のバイト数はIbcntグローバル関数に返されます。

### 発生する可能性のあるエラー
|エラーコード|説明|
|---|---|
|EABO|タイムアウト内にファイルを転送できなかったか、または書き込み操作を開始後にDCL（Device Clear）を受信しました。|
|EADR|ボードレベル: GPIBが正しくアドレス指定されませんでした。ibcmdを使ってGPIBをアドレス指定してください。 デバイスレベル: デバイスのGPIBアドレスとアクセスボードのGPIBアドレス間に競合が存在します。代わりにIbcPAD（IbcSADとibconfig）を使用してください。|
|EARG|flnameが無効です。|
|EBUS|デバイスレベル: デバイスがGPIBに接続されていません。|
|ECIC|デバイスレベル: アクセスボードがCICでありません。デバイスレベルの呼び出しとバスの管理を参照してください。|
|EDVR|NI-488.2ドライバの構成またはインストールが正しくありません。|
|EFSO|ibwrtfがflnameにアクセスできませんでした。|
|EHDL|udが無効または範囲外です。|
|ELCK|他の処理によりロックされているため、要求された動作が行われませんでした。|
|ENEB|インタフェースが取り付けられていないか、正しく構成されていません。|
|EOIP|非同期I/Oの処理中です。|
